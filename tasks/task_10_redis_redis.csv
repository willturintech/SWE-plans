repo,test_patch,problem_statement,FAIL_TO_PASS,PASS_TO_PASS,language
redis/redis,"diff --git a/tests/unit/scripting.tcl b/tests/unit/scripting.tcl
index 5805b563c9f..217ef14e846 100644
--- a/tests/unit/scripting.tcl
+++ b/tests/unit/scripting.tcl
@@ -146,6 +146,14 @@ start_server {tags {""scripting""}} {
         } 1 x
     } {number 1}
 
+    test {EVAL - Lua number -> Redis integer conversion} {
+        r del hash
+        run_script {
+            local foo = redis.pcall('hincrby','hash','field',200000000)
+            return {type(foo),foo}
+        } 0
+    } {number 200000000}
+
     test {EVAL - Redis bulk -> Lua type conversion} {
         r set mykey myval
         run_script {
","[BUG] hIncrBy from lua ""ERR value is not an integer or out of range"" with numeric values of the form n * 100,000,000 in redis 7.2, but not 6.2 or 7.0
**Describe the bug**

We are upgrading our infrastructure to redis 7.2 from 6.2 and our integration tests found an issue which we were able to narrow down to a behavior change in lua scripts.

We have a lua script that does the equivalent of `redis.call(""HINCRBY"", ""key"", ""field"", tonumber(ARGV[1]))`

This works fine in redis 6.2 for all values. Under redis 7.2, the `HINCRBY` throws `ERR value is not an integer or out of range` if and only if `ARGV[1]` is a value that matches the form `n * 100,000,000`. 

**To reproduce**

The following node script can be run in node 20.x or above with the command line: `node <redisUrl>`.

When run, it will call one of two lua scripts that are tiny wrappers around HINCRBY. The first wrapper uses `tonumber`, the second does not.

```javascript
import redis from '@redis/client'

async function main(argv) {
  const client = redis.createClient({
    url: argv[0],
    scripts: {
      badScript: redis.defineScript({
        NUMBER_OF_KEYS: 0,
        SCRIPT: 'redis.call(""HINCRBY"", ""hash"", ""field"", tonumber(ARGV[1]))',
        transformArguments: (delta) => [delta.toString()],
      }),
      goodScript: redis.defineScript({
        NUMBER_OF_KEYS: 0,
        SCRIPT: 'redis.call(""HINCRBY"", ""hash"", ""field"", ARGV[1])',
        transformArguments: (delta) => [delta.toString()],
      }),
    },
  })
  await client.connect()

  for (let i = 0; i <= 2_000_000_000; i += 10_000_000) {
    try {
      await client.goodScript(i)
      console.log('goodScript succeeded', i)
    } catch (e) {
      console.error('goodScript failed', i, e)
    }

    try {
      await client.badScript(i)
      console.log('badScript succeeded', i)
    } catch (e) {
      console.error('badScript failed', i, e)
    }
  }

  await client.quit()
}

await main(process.argv.slice(2))
```

**Expected behavior**

When run with redis 6.2, the script logs:
```
goodScript succeeded 1000000000
badScript succeeded 1000000000
goodScript succeeded 1050000000
badScript succeeded 1050000000
goodScript succeeded 1100000000
badScript succeeded 1100000000
goodScript succeeded 1150000000
badScript succeeded 1150000000
goodScript succeeded 1200000000
badScript succeeded 1200000000
goodScript succeeded 1250000000
badScript succeeded 1250000000
goodScript succeeded 1300000000
badScript succeeded 1300000000
goodScript succeeded 1350000000
badScript succeeded 1350000000
goodScript succeeded 1400000000
badScript succeeded 1400000000
goodScript succeeded 1450000000
badScript succeeded 1450000000
goodScript succeeded 1500000000
badScript succeeded 1500000000
goodScript succeeded 1550000000
badScript succeeded 1550000000
goodScript succeeded 1600000000
badScript succeeded 1600000000
goodScript succeeded 1650000000
badScript succeeded 1650000000
goodScript succeeded 1700000000
badScript succeeded 1700000000
goodScript succeeded 1750000000
badScript succeeded 1750000000
goodScript succeeded 1800000000
badScript succeeded 1800000000
goodScript succeeded 1850000000
badScript succeeded 1850000000
goodScript succeeded 1900000000
badScript succeeded 1900000000
goodScript succeeded 1950000000
badScript succeeded 1950000000
goodScript succeeded 2000000000
badScript succeeded 2000000000
```

**Actual behavior**

When run with redis 7.2, the script logs:
```
goodScript succeeded 1000000000
badScript failed 1000000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1050000000
badScript succeeded 1050000000
goodScript succeeded 1100000000
badScript failed 1100000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1150000000
badScript succeeded 1150000000
goodScript succeeded 1200000000
badScript failed 1200000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1250000000
badScript succeeded 1250000000
goodScript succeeded 1300000000
badScript failed 1300000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1350000000
badScript succeeded 1350000000
goodScript succeeded 1400000000
badScript failed 1400000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1450000000
badScript succeeded 1450000000
goodScript succeeded 1500000000
badScript failed 1500000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1550000000
badScript succeeded 1550000000
goodScript succeeded 1600000000
badScript failed 1600000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1650000000
badScript succeeded 1650000000
goodScript succeeded 1700000000
badScript failed 1700000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1750000000
badScript succeeded 1750000000
goodScript succeeded 1800000000
badScript failed 1800000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1850000000
badScript succeeded 1850000000
goodScript succeeded 1900000000
badScript failed 1900000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
goodScript succeeded 1950000000
badScript succeeded 1950000000
goodScript succeeded 2000000000
badScript failed 2000000000 [ErrorReply: ERR value is not an integer or out of range script: e3e7126938f9468dab2f183f7b9ced79ed09b16f, on @user_script:1.]
```

**Additional information**

Any additional information that is relevant to the problem.

",['EVAL - Lua number -> Redis integer conversion'],"['EVAL - Does Lua interpreter replies to our requests?', 'EVAL - Return _G', 'EVAL - Return table with a metatable that raise error', 'EVAL - Return table with a metatable that call redis', 'EVAL - Lua integer -> Redis protocol type conversion', 'EVAL - Lua string -> Redis protocol type conversion', 'EVAL - Lua true boolean -> Redis protocol type conversion', 'EVAL - Lua false boolean -> Redis protocol type conversion', 'EVAL - Lua status code reply -> Redis protocol type conversion', 'EVAL - Lua error reply -> Redis protocol type conversion', 'EVAL - Lua table -> Redis protocol type conversion', 'EVAL - Are the KEYS and ARGV arrays populated correctly?', 'EVAL - is Lua able to call Redis API?', 'EVAL - Redis integer -> Lua type conversion', 'EVAL - Redis bulk -> Lua type conversion', 'EVAL - Redis multi bulk -> Lua type conversion', 'EVAL - Redis status reply -> Lua type conversion', 'EVAL - Redis error reply -> Lua type conversion', 'EVAL - Redis nil bulk reply -> Lua type conversion', 'EVAL - Is the Lua client using the currently selected DB?', 'EVAL - SELECT inside Lua should not affect the caller', 'EVAL - Scripts do not block on blpop command', 'EVAL - Scripts do not block on brpop command', 'EVAL - Scripts do not block on brpoplpush command', 'EVAL - Scripts do not block on blmove command', 'EVAL - Scripts do not block on bzpopmin command', 'EVAL - Scripts do not block on bzpopmax command', 'EVAL - Scripts do not block on wait', 'EVAL - Scripts do not block on waitaof', 'EVAL - Scripts do not block on XREAD with BLOCK option', 'EVAL - Scripts do not block on XREADGROUP with BLOCK option', 'EVAL - Scripts do not block on XREAD with BLOCK option -- non empty stream', 'EVAL - Scripts do not block on XREADGROUP with BLOCK option -- non empty stream', 'EVAL - Scripts can run non-deterministic commands', 'EVAL - No arguments to redis.call/pcall is considered an error', 'EVAL - redis.call variant raises a Lua error on Redis cmd error (1)', 'EVAL - JSON numeric decoding', 'EVAL - JSON string decoding', 'EVAL - JSON smoke test', 'EVAL - cmsgpack can pack double?', 'EVAL - cmsgpack can pack negative int64?', 'EVAL - cmsgpack pack/unpack smoke test', 'EVAL - cmsgpack can pack and unpack circular references?', 'EVAL - Numerical sanity check from bitop', 'EVAL - Verify minimal bitop functionality', 'EVAL - Able to parse trailing comments', 'EVAL_RO - Successful case', 'EVAL_RO - Cannot run write commands', 'redis.sha1hex() implementation', 'Measures elapsed time os.clock()', 'Prohibit dangerous lua methods in sandbox', 'Verify execution of prohibit dangerous Lua methods will fail', 'Globals protection reading an undeclared global variable', 'Globals protection setting an undeclared global*', 'Test an example script DECR_IF_GT', 'EVAL does not leak in the Lua stack', 'Call Redis command with many args from Lua (issue #1764)', 'Number conversion precision test (issue #1118)', 'String containing number precision test (regression of issue #1118)', 'Verify negative arg count is error instead of crash (issue #1842)', 'Scripts can handle commands with incorrect arity', 'Correct handling of reused argv (issue #1939)', 'Functions in the Redis namespace are able to report errors', 'CLUSTER RESET can not be invoke from within a script', 'Script with RESP3 map', 'Script return recursive object', 'Script check unpack with massive arguments', 'Script read key with expiration set', 'Script del key with expiration set', 'Script ACL check', 'Binary code loading failed', 'Try trick global protection 1', 'Try trick global protection 2', 'Try trick global protection 3', 'Try trick global protection 4', 'Try trick readonly table on redis table', 'Try trick readonly table on json table', 'Try trick readonly table on cmsgpack table', 'Try trick readonly table on bit table', 'Test loadfile are not available', 'Test dofile are not available', 'Test print are not available', 'Timedout read-only scripts can be killed by SCRIPT KILL', 'Timedout read-only scripts can be killed by SCRIPT KILL even when use pcall', 'Timedout script does not cause a false dead client', 'Timedout script link is still usable after Lua returns', 'Timedout scripts and unblocked command', ""Timedout scripts that modified data can't be killed by SCRIPT KILL"", 'SHUTDOWN NOSAVE can kill a timedout script anyway', 'Before the replica connects we issue two EVAL commands', 'Connect a replica to the master instance', 'Replication of script multiple pushes to list with BLPOP', 'Lua scripts using SELECT are replicated correctly', 'Redis.replicate_commands() can be issued anywhere now', 'Redis.set_repl() can be issued before replicate_commands() now', ""Redis.set_repl() don't accept invalid values"", 'Test selective replication of certain Redis commands from Lua', 'PRNG is seeded randomly for command replication', 'Using side effects is not a problem with command replication', 'test RESP2/2 big number protocol parsing', 'test RESP2/2 malformed big number protocol parsing', 'test RESP2/2 map protocol parsing', 'test RESP2/2 set protocol parsing', 'test RESP2/2 double protocol parsing', 'test RESP2/2 null protocol parsing', 'test RESP2/2 verbatim protocol parsing', 'test RESP2/2 true protocol parsing', 'test RESP2/2 false protocol parsing', 'test RESP2/3 big number protocol parsing', 'test RESP2/3 malformed big number protocol parsing', 'test RESP2/3 map protocol parsing', 'test RESP2/3 set protocol parsing', 'test RESP2/3 double protocol parsing', 'test RESP2/3 null protocol parsing', 'test RESP2/3 verbatim protocol parsing', 'test RESP2/3 true protocol parsing', 'test RESP2/3 false protocol parsing', 'test RESP3/2 big number protocol parsing', 'test RESP3/2 malformed big number protocol parsing', 'test RESP3/2 map protocol parsing', 'test RESP3/2 set protocol parsing', 'test RESP3/2 double protocol parsing', 'test RESP3/2 null protocol parsing', 'test RESP3/2 verbatim protocol parsing', 'test RESP3/2 true protocol parsing', 'test RESP3/2 false protocol parsing', 'test RESP3/3 big number protocol parsing', 'test RESP3/3 malformed big number protocol parsing', 'test RESP3/3 map protocol parsing', 'test RESP3/3 set protocol parsing', 'test RESP3/3 double protocol parsing', 'test RESP3/3 null protocol parsing', 'test RESP3/3 verbatim protocol parsing', 'test RESP3/3 true protocol parsing', 'test RESP3/3 false protocol parsing', 'test resp3 attribute protocol parsing', 'Script block the time during execution', 'Script delete the expired key', 'TIME command using cached time', 'Script block the time in some expiration related commands', 'RESTORE expired keys with expiration time', 'Script - disallow write on OOM', 'EVALSHA - Can we call a SHA1 if already defined?', 'EVALSHA_RO - Can we call a SHA1 if already defined?', 'EVALSHA - Can we call a SHA1 in uppercase?', 'EVALSHA - Do we get an error on invalid SHA1?', 'EVALSHA - Do we get an error on non defined SHA1?', 'SCRIPTING FLUSH - is able to clear the scripts cache?', 'SCRIPTING FLUSH ASYNC', 'SCRIPT EXISTS - can detect already defined scripts?', 'SCRIPT LOAD - is able to register scripts in the scripting cache', 'SORT is normally not alpha re-ordered for the scripting engine', 'SORT BY <constant> output gets ordered for scripting', 'SORT BY <constant> with GET gets ordered for scripting', 'random numbers are random now', 'Scripting engine PRNG can be seeded correctly', 'SPOP: We can call scripts rewriting client->argv from Lua', ""MGET: mget shouldn't be propagated in Lua"", 'EXPIRE: We can call scripts rewriting client->argv from Lua', 'INCRBYFLOAT: We can call scripts expanding client->argv from Lua', 'Now use EVALSHA against the master, with both SHAs', ""'x' should be '4' for EVALSHA being replicated by effects"", 'EVALSHA replication when first call is readonly', 'Test scripting debug protocol parsing', 'Test scripting debug lua stack overflow', 'Shebang support for lua engine', 'Unknown shebang option', 'Unknown shebang flag', 'allow-oom shebang flag', 'no-writes shebang flag', 'no-writes shebang flag on replica', 'not enough good replicas', 'not enough good replicas state change during long script', 'allow-stale shebang flag', 'reject script do not cause a Lua stack leak', 'Consistent eval error reporting', 'LUA redis.error_reply API', 'LUA redis.error_reply API with empty string', 'LUA redis.status_reply API', 'LUA test pcall', 'LUA test pcall with error', 'LUA test pcall with non string/integer arg', 'LUA test trim string as expected']",C
