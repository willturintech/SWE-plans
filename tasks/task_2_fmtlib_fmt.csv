repo,test_patch,problem_statement,FAIL_TO_PASS,PASS_TO_PASS,language
fmtlib/fmt,"diff --git a/test/format-test.cc b/test/format-test.cc
index cbed4984a2d0..38399788af1a 100644
--- a/test/format-test.cc
+++ b/test/format-test.cc
@@ -1272,10 +1272,16 @@ TEST(format_test, format_nan) {
   double nan = std::numeric_limits<double>::quiet_NaN();
   EXPECT_EQ(""nan"", fmt::format(""{}"", nan));
   EXPECT_EQ(""+nan"", fmt::format(""{:+}"", nan));
-  if (std::signbit(-nan))
+  EXPECT_EQ(""  +nan"", fmt::format(""{:+06}"", nan));
+  EXPECT_EQ(""+nan  "", fmt::format(""{:<+06}"", nan));
+  EXPECT_EQ("" +nan "", fmt::format(""{:^+06}"", nan));
+  EXPECT_EQ(""  +nan"", fmt::format(""{:>+06}"", nan));
+  if (std::signbit(-nan)) {
     EXPECT_EQ(""-nan"", fmt::format(""{}"", -nan));
-  else
+    EXPECT_EQ(""  -nan"", fmt::format(""{:+06}"", -nan));
+  } else {
     fmt::print(""Warning: compiler doesn't handle negative NaN correctly"");
+  }
   EXPECT_EQ("" nan"", fmt::format(""{: }"", nan));
   EXPECT_EQ(""NAN"", fmt::format(""{:F}"", nan));
   EXPECT_EQ(""nan    "", fmt::format(""{:<7}"", nan));
@@ -1288,6 +1294,11 @@ TEST(format_test, format_infinity) {
   EXPECT_EQ(""inf"", fmt::format(""{}"", inf));
   EXPECT_EQ(""+inf"", fmt::format(""{:+}"", inf));
   EXPECT_EQ(""-inf"", fmt::format(""{}"", -inf));
+  EXPECT_EQ(""  +inf"", fmt::format(""{:+06}"", inf));
+  EXPECT_EQ(""  -inf"", fmt::format(""{:+06}"", -inf));
+  EXPECT_EQ(""+inf  "", fmt::format(""{:<+06}"", inf));
+  EXPECT_EQ("" +inf "", fmt::format(""{:^+06}"", inf));
+  EXPECT_EQ(""  +inf"", fmt::format(""{:>+06}"", inf));
   EXPECT_EQ("" inf"", fmt::format(""{: }"", inf));
   EXPECT_EQ(""INF"", fmt::format(""{:F}"", inf));
   EXPECT_EQ(""inf    "", fmt::format(""{:<7}"", inf));
","Numeric zero fill is applied to inf/nan
From the documentation (emphasis mine):
> Preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. It forces the padding to be placed after the sign or base (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This option is only valid for numeric types and ***it has no effect on formatting of infinity and NaN.***

```CPP
fmt::print(""'{:+06}'\n"", NAN);
// output: '00+nan'
```

https://godbolt.org/z/Pnh33M6r6
","['format_test.format_nan', 'format_test.format_infinity']","['util_test.bit_cast', 'util_test.increment', 'util_test.parse_nonnegative_int', 'util_test.utf8_to_utf16', 'util_test.utf8_to_utf16_empty_string', 'util_test.allocator_ref', 'util_test.format_system_error', 'util_test.system_error', 'util_test.report_system_error', 'memory_buffer_test.ctor', 'memory_buffer_test.move_ctor_inline_buffer', 'memory_buffer_test.move_ctor_dynamic_buffer', 'memory_buffer_test.move_assignment', 'memory_buffer_test.grow', 'memory_buffer_test.allocator', 'memory_buffer_test.exception_in_deallocate', 'memory_buffer_test.max_size_allocator', 'memory_buffer_test.max_size_allocator_overflow', 'format_test.escape', 'format_test.unmatched_braces', 'format_test.no_args', 'format_test.args_in_different_positions', 'format_test.arg_errors', 'format_test.many_args', 'format_test.named_arg', 'format_test.auto_arg_index', 'format_test.empty_specs', 'format_test.left_align', 'format_test.right_align', 'format_test.center_align', 'format_test.fill', 'format_test.plus_sign', 'format_test.minus_sign', 'format_test.space_sign', 'format_test.sign_not_truncated', 'format_test.hash_flag', 'format_test.zero_flag', 'format_test.width', 'format_test.runtime_width', 'format_test.precision', 'format_test.runtime_precision', 'format_test.format_bool', 'format_test.format_short', 'format_test.format_int', 'format_test.format_bin', 'format_test.format_dec', 'format_test.format_hex', 'format_test.format_oct', 'format_test.format_int_locale', 'format_test.format_float', 'format_test.format_double', 'format_test.precision_rounding', 'format_test.prettify_float', 'format_test.format_long_double', 'format_test.format_char', 'format_test.format_volatile_char', 'format_test.format_unsigned_char', 'format_test.format_wchar', 'format_test.format_cstring', 'format_test.format_schar_string', 'format_test.format_uchar_string', 'format_test.format_pointer', 'format_test.format_string', 'format_test.format_string_view', 'format_test.format_foreign_strings', 'format_test.format_custom', 'format_test.format_to_custom', 'format_test.wide_format_string', 'format_test.format_string_from_speed_test', 'format_test.format_examples', 'format_test.print', 'format_test.variadic', 'format_test.dynamic', 'format_test.bytes', 'format_test.join', 'format_test.format_message_example', 'format_test.unpacked_args', 'format_test.compile_time_string', 'format_test.custom_format_compile_time_string', 'format_test.format_udl', 'format_test.named_arg_udl', 'format_test.enum', 'format_test.formatter_not_specialized', 'format_test.non_null_terminated_format_string', 'format_test.dynamic_formatter', 'format_test.to_string', 'format_test.output_iterators', 'format_test.formatted_size', 'format_test.format_to_no_args', 'format_test.format_to', 'format_test.format_to_wide', 'format_test.format_to_memory_buffer', 'format_test.format_to_vector', 'format_test.format_to_propagates_exceptions', 'format_test.format_to_n', 'format_test.format_to_n_output_iterator', 'format_test.char_traits_is_not_ambiguous', 'format_test.format_utf8_precision', 'format_test.back_insert_slicing', 'format_test.test_formatters_enabled', 'format_int_test.data', 'format_int_test.format_int']",C++
