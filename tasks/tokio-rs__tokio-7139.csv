repo,test_patch,problem_statement,FAIL_TO_PASS,PASS_TO_PASS,language
tokio-rs/tokio,"diff --git a/tokio/tests/fs_file.rs b/tokio/tests/fs_file.rs
index d066823d857..e5bc0bd87ff 100644
--- a/tokio/tests/fs_file.rs
+++ b/tokio/tests/fs_file.rs
@@ -1,6 +1,7 @@
 #![warn(rust_2018_idioms)]
 #![cfg(all(feature = ""full"", not(target_os = ""wasi"")))] // WASI does not support all fs operations
 
+use futures::future::FutureExt;
 use std::io::prelude::*;
 use std::io::IoSlice;
 use tempfile::NamedTempFile;
@@ -176,6 +177,24 @@ async fn read_file_from_std() {
     assert_eq!(&buf[..n], HELLO);
 }
 
+#[tokio::test]
+async fn empty_read() {
+    let mut tempfile = tempfile();
+    tempfile.write_all(HELLO).unwrap();
+
+    let mut file = File::open(tempfile.path()).await.unwrap();
+
+    // Perform an empty read and get a length of zero.
+    assert!(matches!(file.read(&mut []).now_or_never(), Some(Ok(0))));
+
+    // Check that we don't get EOF on the next read.
+    let mut buf = [0; 1024];
+    let n = file.read(&mut buf).await.unwrap();
+
+    assert_eq!(n, HELLO.len());
+    assert_eq!(&buf[..n], HELLO);
+}
+
 fn tempfile() -> NamedTempFile {
     NamedTempFile::new().unwrap()
 }
","poll_read on a tokio::fs::File with an empty buffer returns EOF on the *next* poll
**Version**
`tokio v1.43.0`

**Platform**
```
Darwin goffrie-mbp 24.2.0 Darwin Kernel Version 24.2.0: Fri Dec  6 19:01:59 PST 2024; root:xnu-11215.61.5~2/RELEASE_ARM64_T6000 arm64
```
but I believe the bug is cross-platform.

**Description**
The documentation for AsyncRead suggests that calling poll_read with an empty read buffer should return Poll::Ready(Ok(())). However, for fs::File, it instead returns Poll::Pending and then returns Poll::Ready(Ok(())) with no data (i.e. signalling EOF) on the _next_ poll, even if that poll supplies a nonempty buffer.
Tracing the code, `let max_buf_size = cmp::min(dst.remaining(), me.max_buf_size);` [here](https://github.com/tokio-rs/tokio/blob/5086e56dcb85223df27019d80225c29153d96050/tokio/src/fs/file.rs#L606) asks the background thread to read 0 bytes, and then on the next poll we'll do `buf.copy_to(dst);` with zero bytes and immediately return `Poll::Ready(Ok(()));`.

It could be argued that this is not a bug since you shouldn't be calling poll_read with an empty buffer anyway, but this happened to me in the wild and the downstream code _would_ have been correct if tokio::fs::File just returned immediately (notably wrapping the file in a BufReader fixes the issue too).

Reproducer:

```rust
// src/main.rs
use std::{pin::Pin, task::Context};

use futures::task::noop_waker_ref;
use tokio::io::{AsyncRead as _, AsyncReadExt as _, ReadBuf};

#[tokio::main(flavor = ""current_thread"")]
async fn main() {
    let mut file = tokio::fs::File::open(""/dev/zero"").await.unwrap();
    // puts the file in a bad state
    let poll = Pin::new(&mut file).poll_read(&mut Context::from_waker(noop_waker_ref()), &mut ReadBuf::new(&mut []));
    _ = dbg!(poll);
    // should succeed, but doesn't
    file.read_exact(&mut [0; 4096]).await.unwrap();
}
```

```toml
# Cargo.toml
[package]
name = ""repro""
version = ""0.1.0""
edition = ""2021""

[dependencies]
futures = ""0.3.31""
tokio = { version = ""1.43.0"", features = [""rt"", ""fs"", ""macros"", ""io-util""] }
```

I expected to see this happen: `poll = Pending` followed by a successful read of 4096 bytes

Instead, this happened:
```
[src/main.rs:11:9] poll = Pending
thread 'main' panicked at src/main.rs:13:43:
called `Result::unwrap()` on an `Err` value: Custom { kind: UnexpectedEof, error: ""early eof"" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

",['empty_read'],"['read_file_from_unix_fd', 'coop', 'read_file_from_std', 'basic_write_and_shutdown', 'basic_read', 'basic_write', 'set_max_buf_size_read', 'file_debug_fmt', 'write_into_std', 'set_max_buf_size_write', 'rewind_seek_position', 'unix_fd_is_valid', 'write_into_std_immediate', 'write_vectored_and_shutdown', 'write_to_clone', 'write_vectored']",Rust
