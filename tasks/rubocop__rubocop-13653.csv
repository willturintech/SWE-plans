repo,test_patch,problem_statement,FAIL_TO_PASS,PASS_TO_PASS,language
rubocop/rubocop,"diff --git a/spec/rubocop/cop/style/access_modifier_declarations_spec.rb b/spec/rubocop/cop/style/access_modifier_declarations_spec.rb
index 310499a523bf..b4fd0e79e73d 100644
--- a/spec/rubocop/cop/style/access_modifier_declarations_spec.rb
+++ b/spec/rubocop/cop/style/access_modifier_declarations_spec.rb
@@ -271,6 +271,39 @@ class Foo
         end
       end
     end
+
+    context 'allow access modifiers on alias_method' do
+      let(:cop_config) { { 'AllowModifiersOnAliasMethod' => true } }
+
+      it ""accepts when argument to #{access_modifier} is an alias_method"" do
+        expect_no_offenses(<<~RUBY)
+          class Foo
+            #{access_modifier} alias_method :bar, :foo
+          end
+        RUBY
+      end
+    end
+
+    context 'do not allow access modifiers on alias_method' do
+      let(:cop_config) { { 'AllowModifiersOnAliasMethod' => false } }
+
+      it ""registers an offense when argument to #{access_modifier} is an alias_method"" do
+        expect_offense(<<~RUBY, access_modifier: access_modifier)
+          class Foo
+            #{access_modifier} alias_method :bar, :foo
+            ^{access_modifier} `#{access_modifier}` should not be inlined in method definitions.
+          end
+        RUBY
+
+        expect_correction(<<~RUBY)
+          class Foo
+          #{access_modifier}
+
+          alias_method :bar, :foo
+          end
+        RUBY
+      end
+    end
   end
 
   context 'when `group` is configured' do
","Add option to `AllowModifiersOnAttrs` cop to allow the use of private before `alias_method`
## Is your feature request related to a problem? Please describe.

I would like to specify that I'm OK with using private in front of `alias_method`, in the same way, it's currently possible to do with `attr`.

## Describe the solution you'd like

```ruby
class Result
  # ...
  # The following line will raise an offense   
  private alias_method :value_for_deconstruct, :value # => Style/AccessModifierDeclarations: private should not be inlined in method definitions.
end        
```

```yaml
AllowModifiersOnAttrs
  AllowModifiersOnAliasMethod: true
```

Perhaps it would be best to leave the default value as `false` since it could break existing code but I think it's a valid use case, 

`Module#alias_method` is in Core Ruby, but I'm not sure how common this use case is, if there's enough interest to integrate it, I'm willing to implement it myself.

","['accepts when argument to module_function is an alias_method', 'accepts when argument to private is an alias_method', 'accepts when argument to protected is an alias_method', 'accepts when argument to public is an alias_method']","['accepts multiple arguments on attrs', 'accepts when argument to module_function is a splat with a method call', 'accepts when argument to module_function is a symbol', 'accepts when argument to module_function is an attr_*', 'accepts when argument to module_function is multiple symbols', 'accepts when argument to module_function is splat with a `%i` array literal', 'accepts when argument to module_function is splat with a constant', 'accepts when argument to private is a splat with a method call', 'accepts when argument to private is a symbol', 'accepts when argument to private is an attr_*', 'accepts when argument to private is multiple symbols', 'accepts when argument to private is splat with a `%i` array literal', 'accepts when argument to private is splat with a constant', 'accepts when argument to protected is a splat with a method call', 'accepts when argument to protected is a symbol', 'accepts when argument to protected is an attr_*', 'accepts when argument to protected is multiple symbols', 'accepts when argument to protected is splat with a `%i` array literal', 'accepts when argument to protected is splat with a constant', 'accepts when argument to public is a splat with a method call', 'accepts when argument to public is a symbol', 'accepts when argument to public is an attr_*', 'accepts when argument to public is multiple symbols', 'accepts when argument to public is splat with a `%i` array literal', 'accepts when argument to public is splat with a constant', 'accepts when module_function is a hash literal value', 'accepts when private is a hash literal value', 'accepts when protected is a hash literal value', 'accepts when public is a hash literal value', 'accepts when using only module_function', 'accepts when using only private', 'accepts when using only protected', 'accepts when using only public', 'does not offend when module_function does not have right sibling node', 'does not offend when module_function is inlined with a method', 'does not offend when module_function is inlined with a symbol', 'does not offend when module_function is not inlined', 'does not offend when module_function is not inlined and has a comment', 'does not offend when private does not have right sibling node', 'does not offend when private is inlined with a method', 'does not offend when private is inlined with a symbol', 'does not offend when private is not inlined', 'does not offend when private is not inlined and has a comment', 'does not offend when protected does not have right sibling node', 'does not offend when protected is inlined with a method', 'does not offend when protected is inlined with a symbol', 'does not offend when protected is not inlined', 'does not offend when protected is not inlined and has a comment', 'does not offend when public does not have right sibling node', 'does not offend when public is inlined with a method', 'does not offend when public is inlined with a symbol', 'does not offend when public is not inlined', 'does not offend when public is not inlined and has a comment', 'does not register an offense when using module_function in a block', 'does not register an offense when using private in a block', 'does not register an offense when using protected in a block', 'does not register an offense when using public in a block', 'offends when module_function is inlined with a method', 'offends when module_function is inlined with a method on the top level', 'offends when module_function is not inlined', 'offends when module_function is not inlined and has a comment', 'offends when multiple groupable access modifiers are defined', 'offends when private is inlined with a method', 'offends when private is inlined with a method on the top level', 'offends when private is not inlined', 'offends when private is not inlined and has a comment', 'offends when protected is inlined with a method', 'offends when protected is inlined with a method on the top level', 'offends when protected is not inlined', 'offends when protected is not inlined and has a comment', 'offends when public is inlined with a method', 'offends when public is inlined with a method on the top level', 'offends when public is not inlined', 'offends when public is not inlined and has a comment', 'registers an offense and autocorrects when methods are all defined in class', 'registers an offense and autocorrects when methods are all defined in class and there is a comment', 'registers an offense and autocorrects when methods are all defined in class and there is already a bare access modifier', 'registers an offense and autocorrects when not all methods are defined in class', 'registers an offense and does not autocorrect when methods are not defined', 'registers an offense but does not autocorrect it', 'registers an offense for a single symbol', 'registers an offense for correct + multiple opposite styles of module_function usage', 'registers an offense for correct + multiple opposite styles of private usage', 'registers an offense for correct + multiple opposite styles of protected usage', 'registers an offense for correct + multiple opposite styles of public usage', 'registers an offense for multiple symbols', 'registers an offense when argument to module_function is a symbol', 'registers an offense when argument to module_function is an alias_method', 'registers an offense when argument to module_function is splat with a `%i` array literal', 'registers an offense when argument to module_function is splat with a constant', 'registers an offense when argument to private is a symbol', 'registers an offense when argument to private is an alias_method', 'registers an offense when argument to private is splat with a `%i` array literal', 'registers an offense when argument to private is splat with a constant', 'registers an offense when argument to protected is a symbol', 'registers an offense when argument to protected is an alias_method', 'registers an offense when argument to protected is splat with a `%i` array literal', 'registers an offense when argument to protected is splat with a constant', 'registers an offense when argument to public is a symbol', 'registers an offense when argument to public is an alias_method', 'registers an offense when argument to public is splat with a `%i` array literal', 'registers an offense when argument to public is splat with a constant', 'registers and autocorrects an offense', 'registers and autocorrects offense if conditional modifier is followed by a normal one', 'registers and autocorrects offense if conditional modifiers wrap a normal one']",Ruby
